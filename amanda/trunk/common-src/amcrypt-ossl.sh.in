#!@SHELL@
#
# amcrypt-ossl.sh - crypto helper using OpenSSL
# Usage: amcrypt-ossl.sh [-d]
#

# change these as needed
OPENSSL=			# whatever's in $PATH
CIPHER=aes-256-cbc		# see `openssl help` for more ciphers
AMANDA_HOME=~@CLIENT_LOGIN@
RANDFILE=$AMANDA_HOME/.rnd
export RANDFILE
PASSPHRASE=$AMANDA_HOME/.am_passphrase	# required

# where might openssl be?
PATH=/bin:/usr/bin:/usr/local/bin:/usr/ssl/bin:/usr/local/ssl/bin
export PATH
ME=`basename "$0"`

#+
# Function to:
#    Simplify gettext usage by allowing printf format
#    strings for translators, use _() identifier for
#    xgettext extraction similar to "C" usage and
#    collapsing "printf `gettext fmt` ...", which is
#    used everywhere, into one function.
#-
_() {
	fmt=`gettext -d amanda "$1"`
	shift
	printf "$fmt" $*
}


if [ -z "${OPENSSL:=`which openssl`}" ]; then
	echo `_ '%s: %s not found' "${ME}" "openssl"` >&2
	exit 1
elif [ ! -x "${OPENSSL}" ]; then
	echo `_ '%s: can't execute openssl (%s)' "${ME}" "${OPENSSL}"` >&2
	exit 1
fi

# we'll need to pad the datastream to a multiple of the cipher block size prior
# to encryption. 96 bytes (= 768 bits) should be good for any cipher.
pad() {
	perl -pe 'BEGIN { $bs = 96; $/ = \8192 } $nbytes = ($nbytes + length) % $bs; END { print "\0" x ($bs - $nbytes) }'
}

if [ "$1" = -d ]; then
	# decrypt
	"${OPENSSL}" enc -d "-${CIPHER}" -nopad -salt -pass fd:3 3< "${PASSPHRASE}"
else
	# encrypt
	pad | "${OPENSSL}" enc -e "-${CIPHER}" -nopad -salt -pass fd:3 3< "${PASSPHRASE}"
fi

