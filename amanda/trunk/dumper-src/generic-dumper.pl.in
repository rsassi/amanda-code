

$command = $ARGV[0];
if ($command eq "privilege") {
   wrapper_privilege();
}
elsif ($command eq "support") {
   wrapper_support();
}
elsif ($command eq "selfcheck") {
   wrapper_selfcheck();
}
elsif ($command eq "estimate") {
   wrapper_estimate();
}
elsif ($command eq "estimate-parse") {
   wrapper_estimate_parse();
}
elsif ($command eq "backup") {
   wrapper_backup();
}
elsif ($command eq "backup-parse") {
   wrapper_backup_parse();
}
elsif ($command eq "index-from-output") {
   wrapper_index_from_output();
}
elsif ($command eq "index-from-image") {
   wrapper_index_from_image();
}
elsif ($command eq "restore") {
   wrapper_restore();
}
elsif ($command eq "print-command") {
   wrapper_print_command();
}
else {
   printf STDERR "Unknown command `$command'.\n";
   exit 1;
}


sub wrapper_privilege() {
   if(defined(&command_support)) {
      command_privilege();
      exit 0;
   }
   my($subcommand) = $ARGV[1];
   if ($subcommand eq "support") {
      wrapper_print_privilege($subcommand);
   }
   elsif ($subcommand eq "selfcheck") {
      wrapper_print_privilege($subcommand);
   }
   elsif ($subcommand eq "estimate") {
      wrapper_print_privilege($subcommand);
   }
   elsif ($subcommand eq "estimate-parse") {
      wrapper_print_privilege($subcommand);
   }
   elsif ($subcommand eq "backup") {
      wrapper_print_privilege($subcommand);
   }
   elsif ($subcommand eq "backup-parse") {
      wrapper_print_privilege($subcommand);
   }
   elsif ($subcommand eq "index-from-output") {
      wrapper_print_privilege($subcommand);
   }
   elsif ($subcommand eq "index-from-image") {
      wrapper_print_privilege($subcommand);
   }
   elsif ($subcommand eq "restore") {
      wrapper_print_privilege($subcommand);
   }
   elsif ($subcommand eq "print-command") {
      wrapper_print_privilege($subcommand);
   }
   else {
      printf STDERR "Unknown command `$subcommand'.\n";
      exit 1;
   }
   if(defined($user_default) && defined($group_default)) {
      print "USER $user_default\n";
      print "GROUP $group_default\n";
      exit 0;
   }
   exit 0;
}


sub wrapper_print_privilege {
   my($command) = @_;
   $command =~ s/-/_/g;
   my($var_user) = "user_$command";
   my($var_group) = "group_$command";
   if(defined($$var_user) && defined($$var_group)) {
      print "USER $$var_user\n";
      print "GROUP $$var_group\n";
      exit 0;
   }
   elsif(defined($$var_user) && !defined($$var_group)) {
      print STDERR "\$$var_user defined but \$$var_group not defined\n";
      exit 1;
   }
   elsif(!defined($$var_user) && defined($$var_group)) {
      print STDERR "\$$var_group defined but \$$var_user not defined\n";
      exit 1;
   }
}

sub wrapper_support() {
   if(defined(&command_support)) {
      command_support();
      exit 0;
   }
   my($subcommand) = $ARGV[1];
   if ($subcommand eq "level-incrementals") {
      if (defined($level_incrementals)) {
         print "$level_incrementals\n";
      }
      else {
         print "1\n";
      }
      exit 0;
   }
   elsif ($subcommand eq "index") {
      my($index_generation);
      foreach $index_generation (@index_generation) {
         if( $index_generation eq "direct" ||
             $index_generation eq "parse"  ||
             $index_generation eq "output" ||
             $index_generation eq "image") {
                print "$index_generation\n";
         }
         else {
            print "unknow indexing method '$index_generation'\n";
         }
      }
   exit 0;
   }
   elsif ($subcommand eq "parse-estimate") {
      my($parse_estimate);
      foreach $parse_estimate (@parse_estimate) {
         if( $parse_estimate eq "direct" ||
             $parse_estimate eq "parse" ) {
            print "$parse_estimate\n";
         }
         else {
            print "unknow parse-estimate method '$parse_estimate'\n";
         }
      }
   exit 0;
   }
   elsif ($subcommand eq "parse-backup") {
      print "direct\n" if (defined($parse_backup_direct));
      print "parse\n"  if (defined($parse_backup_parse));
      my($parse_backup);
      foreach $parse_backup (@parse_backup) {
         if( $parse_backup eq "direct" ||
             $parse_backup eq "parse" ) {
            print "$parse_backup\n";
         }
         else {
            print "unknow parse-backup method '$parse_backup'\n";
         }
      }
      exit 0;
   }
   else {
      exit 1;
   }
}

sub wrapper_selfcheck() {
   if(defined(&command_selfcheck)) {
      command_selfcheck();
   }
   else {
      exit 1;
   }
}

sub wrapper_estimate() {
   my($estimate_type) = $ARGV[1];
   my($option);
   my($estimate_type_is_ok) = 0;
   my($backups_type);
   foreach $backups_type (@backup_type) {
      $estimate_type_is_ok = 1 if($estimate_type eq $backups_type);
   }
   if($estimate_type_is_ok == 0) {
      print "estimate type `$estimate_type' not supported.\n";
      exit 3;
   }
   $option = 3 if ($estimate_type eq "full");
   $option = 4 if ($estimate_type eq "level");
   $option = 4 if ($estimate_type eq "diff");
   parse_options($option);
   if($option_estimate_direct + $option_estimate_parse > 1) {
      print "Can't define both `estimate-direct' and `estimate-parse'.\n";
      exit 5;
   }
   elsif($option_estimate_direct + $option_estimate_parse == 0) {
      print "You must have the option `estimate-direct' or `estimate-parse'.\n";
      exit 5;
   }
   if($estimate_type eq "full") {
      command_estimate_full($ARGV[2]);
   }
    elsif($estimate_type eq "level") {
      command_estimate_level($ARGV[2], $ARGV[3]);
   }
   elsif($estimate_type eq "diff") {
      command_estimate_diff($ARGV[2], $ARGV[3]);
   }
}

sub wrapper_estimate_parse() {
   if(defined(&command_estimate_parse)) {
      command_estimate_parse();
   }
   else {
      printf STDERR "`estimate-parse' is not supported.\n";
      exit 1;
   }
}

sub wrapper_backup() {
   my($backup_type) = $ARGV[1];
   my($option);
   my($backup_type_is_ok) = 0;
   my($backups_type);
   foreach $backups_type (@backup_type) {
      $backup_type_is_ok = 1 if($backup_type eq $backups_type);
   }
   if($backup_type_is_ok == 0) {
      print "backup type `$backup_type' not supported.\n";
      exit 3;
   }
   $option = 3 if ($backup_type eq "full");
   $option = 4 if ($backup_type eq "level");
   $option = 4 if ($backup_type eq "diff");
   parse_options($option);
   if($option_backup_direct + $option_backup_parse > 1) {
      print "Can't define both `backup-direct' and `backup-parse'.\n";
      exit 5;
   }
   elsif($option_backup_direct + $option_backup_parse == 0) {
      print "You must have the option `backup-direct' or `backup-parse'.\n";
      exit 5;
   }
   if($backup_type eq "full") {
      command_backup_full($ARGV[2]);
   }
   elsif($backup_type eq "level") {
      command_backup_level($ARGV[2], $ARGV[3]);
   }
   elsif($backup_type eq "diff") {
      command_backup_diff($ARGV[2], $ARGV[3]);
   }
}

sub wrapper_backup_parse() {
   if(defined(&command_backup_parse)) {
      command_backup_parse();
   }
   else {
      printf STDERR "`backup-parse' is not supported.\n";
      exit 1;
   }
}

sub wrapper_index_from_output() {
   if(defined(&command_index_from_output)) {
      command_index_from_output();
   }
   else {
      printf STDERR "`index-from-output' is not supported.\n";
      exit 1;
   }
}

sub wrapper_index_from_image() {
   if(defined(&command_index_from_image)) {
      command_index_from_image();
   }
   else {
      printf STDERR "command `index-from-image' is not supported.\n";
      exit 1;
   }
}

sub wrapper_restore() {
   if(defined(&command_restore)) {
      command_restore();
   }
   else {
     printf STDERR "`restore' is not supported.\n";
     exit 1;
   }
}

sub wrapper_print_command() {
   if(defined(&command_print_command)) {
      command_print_command();
   }
   else {
      printf STDERR "`print-command' is not supported.\n";
      exit 1;
   }
}


sub parse_options() {
   my($no_option) = @_;
   my($options, @options, $option, $name, $option_name, $value);

   while($no_option <= $#ARGV) {
      $options = $ARGV[${no_option}];
      @options = split (/;/,$options);
      foreach $option (@options) {
         if( $option =~ /=/ ) {
            ($name,$value) = split(/=/,$option);
         }
         else {
            $name  = $option;
            $value = 1;
         }
         $option_name = "option_$name";
         $option_name =~ s/\-/\_/g;
	 $$option_name = $value;
      }
      $no_option++;
   }
}

sub check_file {
   my($filename, $mode) = @_;

   stat($filename);

   if($mode eq "e") {
      if( -e _ ) {
         print "OK $filename exists\n";
      }
      else {
         print "ERROR [can not find $filename]\n";
      }
   }
   elsif($mode eq "x") {
      if( -x _ ) {
         print "OK $filename executable\n";
      }
      else {
         print "ERROR [can not execute $filename]\n";
      }
   }
   elsif($mode eq "r") {
      if( -r _ ) {
         print "OK $filename readable\n";
      }
      else {
         print "ERROR [can not read $filename]\n";
      }
   }
   elsif($mode eq "w") {
      if( -w _ ) {
         print "OK $filename writable\n";
      }
      else {
         print "ERROR [can not write $filename]\n";
      }
   }
   else {
      print "ERROR [check_file: unknow mode $mode]\n";
   }
}

sub check_dir {
}

sub check_suid {
}

1;
