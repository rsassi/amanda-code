/*
 * Copyright (c) 2005 Zmanda, Inc.  All Rights Reserved.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License version 2.1 as 
 * published by the Free Software Foundation.
 * 
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA.
 * 
 * Contact information: Zmanda Inc., 505 N Mathlida Ave, Suite 120
 * Sunnyvale, CA 94085, USA, or: http://www.zmanda.com
 */

#include <string.h> /* memset() */

#include "vfs-device.h"
#include "amanda.h"
#include <regex.h>

/* This regex will match all VfsDevice files in a directory. We use it
   for cleanup and verification. Note that this regex does NOT match
   the volume label. */
#define VFS_DEVICE_FILE_REGEX "^[0-9]+[\\.-]"

/* The name of the volume lockfile. Should be the same as that
   generated by lockfile_name(0). */
#define VOLUME_LOCKFILE_NAME "00000-lock"

/* here are local prototypes */
static void vfs_device_init (VfsDevice * o);
static void vfs_device_class_init (VfsDeviceClass * c);
static void vfs_device_finalize (GObject * o);

static gboolean vfs_device_start(Device * pself, DeviceAccessMode mode,
                                 char * label, char * timestamp);
static gboolean vfs_device_open_device (Device * pself,
                                        char * device_name);
static gboolean vfs_device_start_file (Device * pself, const dumpfile_t * ji);
static gboolean vfs_device_finish_file (Device * pself);
static dumpfile_t * vfs_device_seek_file (Device * self, guint file);
static gboolean vfs_device_seek_block (Device * self, guint64 block);
static gboolean vfs_device_property_get (Device * pself, DevicePropertyId ID,
                                         GValue * val);
static gboolean vfs_device_property_set (Device * pself, DevicePropertyId ID,
                                         GValue * val);
static gboolean vfs_device_recycle_file (Device * pself, guint filenum);
static Device * vfs_device_factory(char * device_type,
                                   char * device_name);
static gboolean vfs_device_read_label(Device * dself);
static void     vfs_device_label_size_range(FdDevice * self,
                                            guint * min, guint * max);
static gboolean vfs_device_write_block(Device * self, guint size,
                                       gpointer data, gboolean last_block);

/* Various helper functions. */
static void release_file(VfsDevice * self);
static gboolean check_is_dir(const char * name, gboolean printmsg);
static char* file_number_to_file_name(VfsDevice * self, guint file);
static gboolean file_number_to_file_name_functor(const char * filename,
                                                 gpointer datap);
static char* lockfile_name(VfsDevice * self, guint file);
static gboolean open_lock(VfsDevice * self, int file, gboolean exclusive);
static void promote_volume_lock(VfsDevice * self);
static void demote_volume_lock(VfsDevice * self);
static gboolean delete_vfs_files(VfsDevice * self);
static gboolean delete_vfs_files_functor(const char * filename,
                                         gpointer self);
static gboolean check_dir_empty_functor(const char * filename,
                                        gpointer self);
static gboolean clear_and_prepare_label(VfsDevice * self, char * label);
static gint get_last_file_number(VfsDevice * self);
static gboolean get_last_file_number_functor(const char * filename,
                                             gpointer datap);
static char * make_new_file_name(VfsDevice * self, const dumpfile_t * ji);
static gboolean try_unlink(const char * file);

/* pointer to the classes of our parents */
#define device_parent_class ((DeviceClass*)parent_class)
static FdDeviceClass *parent_class = NULL;

void vfs_device_register(void) {
    static const char * device_prefix_list[] = { "file", NULL };
    register_device(vfs_device_factory, device_prefix_list);
}

GType
vfs_device_get_type (void)
{
    static GType type = 0;

    if G_UNLIKELY(type == 0) {
        static const GTypeInfo info = {
            sizeof (VfsDeviceClass),
            (GBaseInitFunc) NULL,
            (GBaseFinalizeFunc) NULL,
            (GClassInitFunc) vfs_device_class_init,
            (GClassFinalizeFunc) NULL,
            NULL /* class_data */,
            sizeof (VfsDevice),
            0 /* n_preallocs */,
            (GInstanceInitFunc) vfs_device_init,
            NULL
        };

        type = g_type_register_static (TYPE_FD_DEVICE, "VfsDevice",
                                       &info, (GTypeFlags)0);
    }
    
    return type;
}

static void 
vfs_device_init (VfsDevice * self) {
    Device * o;
    DeviceProperty prop;
    GValue response;

    self->dir_handle = NULL;
    self->dir_name = self->file_name = NULL;
    self->file_lock_name = self->volume_lock_name = NULL;
    self->file_lock_fd = self->volume_lock_fd = -1;
    self->block_size = VFS_DEVICE_DEFAULT_BLOCK_SIZE;
    self->volume_bytes = 0; 
    self->volume_limit = 0;

    /* Register Properties */
    o = DEVICE(self);
    bzero(&response, sizeof(response));
    prop.base = &device_property_concurrency;
    prop.access = PROPERTY_ACCESS_GET_MASK;
    g_value_init(&response, CONCURRENCY_PARADIGM_TYPE);
    g_value_set_enum(&response, CONCURRENCY_PARADIGM_RANDOM_ACCESS);
    device_add_property(o, &prop, &response);
    g_value_unset(&response);

    prop.base = &device_property_streaming;
    g_value_init(&response, STREAMING_REQUIREMENT_TYPE);
    g_value_set_enum(&response, STREAMING_REQUIREMENT_NONE);
    device_add_property(o, &prop, &response);
    g_value_unset(&response);

    prop.base = &device_property_min_block_size;
    g_value_init(&response, G_TYPE_UINT);
    g_value_set_uint(&response, VFS_DEVICE_MIN_BLOCK_SIZE);
    device_add_property(o, &prop, &response);

    prop.base = &device_property_max_block_size;
    g_value_set_uint(&response, VFS_DEVICE_MAX_BLOCK_SIZE);
    device_add_property(o, &prop, &response);
    g_value_unset(&response);

    prop.base = &device_property_appendable;
    g_value_init(&response, G_TYPE_BOOLEAN);
    g_value_set_boolean(&response, TRUE);
    device_add_property(o, &prop, &response);

    prop.base = &device_property_partial_deletion;
    device_add_property(o, &prop, &response);
    g_value_unset(&response);

    /* This one is handled by Device's get_property handler. */
    prop.base = &device_property_canonical_name;
    device_add_property(o, &prop, NULL);

    prop.base = &device_property_medium_access_type;
    g_value_init(&response, MEDIA_ACCESS_MODE_TYPE);
    g_value_set_enum(&response, MEDIA_ACCESS_MODE_READ_WRITE);
    device_add_property(o, &prop, &response);
    g_value_unset(&response);

    /* These are dynamic, handled in vfs_device_property_xxx */
    prop.base = &device_property_block_size;
    prop.access = PROPERTY_ACCESS_GET_MASK | PROPERTY_ACCESS_SET_BEFORE_START;
    device_add_property(o, &prop, NULL);

    prop.base = &device_property_max_volume_usage;
    prop.access =
        (PROPERTY_ACCESS_GET_MASK | PROPERTY_ACCESS_SET_MASK) &
        (~ PROPERTY_ACCESS_SET_INSIDE_FILE_WRITE);
}

static void 
vfs_device_class_init (VfsDeviceClass * c G_GNUC_UNUSED)
{
    GObjectClass *g_object_class = (GObjectClass*) c;
    DeviceClass *device_class = (DeviceClass *)c;
    FdDeviceClass *fd_device_class = (FdDeviceClass *)c;

    parent_class = g_type_class_ref(TYPE_FD_DEVICE);

    device_class->open_device = vfs_device_open_device;
    device_class->start = vfs_device_start;
    device_class->start_file = vfs_device_start_file;
    device_class->read_label = vfs_device_read_label;
    device_class->write_block = vfs_device_write_block;
    device_class->finish_file = vfs_device_finish_file;
    device_class->seek_file = vfs_device_seek_file;
    device_class->seek_block = vfs_device_seek_block;
    device_class->property_get = vfs_device_property_get;
    device_class->property_set = vfs_device_property_set;
    device_class->recycle_file = vfs_device_recycle_file;
    fd_device_class->label_size_range = vfs_device_label_size_range;
    g_object_class->finalize = vfs_device_finalize;
}

/* Drops everything associated with the volume file: Its name and fd,
   its lock, and its lock's name and fd. */
static void release_file(VfsDevice * self) {
    /* Doesn't hurt. */
    close(FD_DEVICE(self)->fd);
    amfree(self->file_name);

    if (self->file_lock_fd > 0) {
        amfunlock(self->file_lock_fd, self->file_lock_name);
        close(self->file_lock_fd);
        amfree(self->file_lock_name);
    }
    self->file_lock_fd = FD_DEVICE(self)->fd = -1;
}

static void vfs_device_finalize(GObject * obj_self) {
    VfsDevice *self = VFS_DEVICE (obj_self);

    if(G_OBJECT_CLASS(parent_class)->finalize)
        (* G_OBJECT_CLASS(parent_class)->finalize)(obj_self);
    /* Above frees self->dir_name. */
    self->dir_name = NULL;

    if(self->dir_handle) {
        closedir (self->dir_handle);
        self->dir_handle = NULL;
    }

    if (self->volume_lock_fd >= 0) {
        amfunlock(self->volume_lock_fd, self->volume_lock_name);
        close(self->volume_lock_fd);
    }

    release_file(self);

    amfree(self->volume_lock_name);
}

static Device * vfs_device_factory(char * device_type,
                                   char * device_name) {
    Device * rval;
    g_assert(0 == strcmp(device_type, "file"));
    rval = DEVICE(g_object_new(TYPE_VFS_DEVICE, NULL));
    if (!device_open_device(rval, device_name)) {
        g_object_unref(rval);
        return NULL;
    } else {
        return rval;
    }
}

static gboolean check_is_dir(const char * name, gboolean printmsg) {
    struct stat dir_status;
    
    if (stat(name, &dir_status) < 0) {
#ifdef EINTR
        if (errno == EINTR) {
            return check_is_dir(name, printmsg);
        }
#endif /* EINTR */
        if (printmsg) {
            fprintf(stderr, "Error checking directory %s: %s\n",
                    name, strerror(errno));
        }
        return FALSE;
    } else if (!S_ISDIR(dir_status.st_mode)) {
        if (printmsg) {
            fprintf(stderr, "VFS Device path %s is not a directory.\n",
                    name);
        }
        return FALSE;
    } else {
        return TRUE;
    }
}

typedef struct {
    VfsDevice * self;
    int count;
    char * result;
} fnfn_data;

/* A SearchDirectoryFunctor. */
static gboolean file_number_to_file_name_functor(const char * filename,
                                                 gpointer datap) {
    char * result_tmp;
    struct stat file_status;
    fnfn_data *data = (fnfn_data*)datap;
    
    result_tmp = vstralloc(data->self->dir_name, "/", filename, NULL);    
    
    /* Just to be thorough, let's check that it's a real
       file. */
    if (0 != stat(result_tmp, &file_status)) {
        fprintf(stderr, "Cannot stat file %s (%s), ignoring it.\n", 
                result_tmp, strerror(errno));
    } else if (!S_ISREG(file_status.st_mode)) {
        fprintf(stderr, "%s is not a regular file, ignoring it.\n",
                result_tmp);
    } else {
        data->count ++;
        if (data->result == NULL) {
            data->result = result_tmp;
            result_tmp = NULL;
        }
    }
    amfree(result_tmp);
    return TRUE;
}

/* This function finds the filename for a given file number. We search
 * for a filesystem file matching the regex /^0*$device_file\./; if
 * there is more than one such file we make a warning and take an
 * arbitrary one. */
static char * file_number_to_file_name(VfsDevice * self, guint device_file) {
    char * regex;
    fnfn_data data;

    g_return_val_if_fail(self != NULL, NULL);
    data.self = self;
    data.count = 0;
    data.result = NULL;

    regex = g_strdup_printf("^0*%u\\.", device_file);

    search_directory(self->dir_handle, regex,
                     file_number_to_file_name_functor, &data);

    amfree(regex);

    if (data.count == 0) {
        g_assert(data.result == NULL);
        return NULL;
    } else if (data.count > 1) {
        fprintf(stderr,
                "Found multiple names for file number %d, choosing file %s.\n",
                device_file, data.result);
    } else {
        g_assert(data.result != NULL);
        return data.result;
    }
    g_assert_not_reached();
    return NULL;
}

/* This function returns the dynamically-allocated lockfile name for a
   given file number. */
static char * lockfile_name(VfsDevice * self, guint number) {
    return g_strdup_printf("%s/%05d-lock", self->dir_name, number);
}

/* Does what you expect. If the lock already exists, it is released
 * and regained, in case the mode is changing.
 * The file field has several options:
 * - file > 0: Open a lock on a real volume file.
 * - file = 0: Open the volume lock as a volume file (for setup).
 * - file < 0: Open the volume lock as a volume lock (persistantly).
 */
static gboolean open_lock(VfsDevice * self, int file, gboolean exclusive) {
    int fd;
    char * name;
    
    /* At the moment, file locking is horribly broken. */
    return TRUE;

    if (file < 0) {
        if (self->volume_lock_name == NULL) {
            self->volume_lock_name = lockfile_name(self, 0);
        } else if (self->volume_lock_fd >= 0) {
            amfunlock(self->volume_lock_fd, self->volume_lock_name);
            close(self->volume_lock_fd);
        }
        name = self->volume_lock_name;
    } else {
        if (self->file_lock_fd >= 0 && self->file_lock_name != NULL) {
            amfunlock(self->file_lock_fd, self->file_lock_name);
        }
        amfree(self->file_lock_name);
        close(self->file_lock_fd);
        name = self->file_lock_name = lockfile_name(self, file);
    }
        

    fd = robust_open(name, O_CREAT | O_WRONLY, VFS_DEVICE_CREAT_MODE);

    if (fd < 0) {
        fprintf(stderr, "Can't open lock file %s: %s\n",
                name, strerror(errno));
        return FALSE;
    }

    if (exclusive) {
        amflock(fd, name);
    } else {
        amroflock(fd, name);
    }

    if (file < 0) {
        self->volume_lock_fd = fd;
    } else {
        self->file_lock_fd = fd;
    }
    return TRUE;
}

/* For now, does it the bad way. */
static void promote_volume_lock(VfsDevice * self) {
    amfunlock(self->volume_lock_fd, self->volume_lock_name);
    amflock(self->volume_lock_fd, self->volume_lock_name);
}

static void demote_volume_lock(VfsDevice * self) {
    amfunlock(self->volume_lock_fd, self->volume_lock_name);
    amroflock(self->volume_lock_fd, self->volume_lock_name);
}

/* A SearchDirectoryFunctor */
static gboolean update_volume_size_functor(const char * filename,
                                           gpointer user_data) {
    char * full_filename;
    struct stat stat_buf;
    VfsDevice * self = user_data;
    g_return_val_if_fail(IS_VFS_DEVICE(self), FALSE);
    
    full_filename = vstralloc(self->dir_name, "/", filename, NULL);

    if (stat(full_filename, &stat_buf) < 0) {
        /* Log it and keep going. */
        fprintf(stderr, "Couldn't stat file %s: %s\n",
                full_filename, strerror(errno));
        amfree(full_filename);
        return TRUE;
    }

    amfree(full_filename);
    self->volume_bytes += stat_buf.st_size;

    return TRUE;
}

static void update_volume_size(VfsDevice * self) {
    search_directory(self->dir_handle, "^[0-9]+\\.",
                     update_volume_size_functor, self);

}

static gboolean 
vfs_device_open_device (Device * pself, char * device_name) {
    VfsDevice * self;
    char * subdir;
    
    self = VFS_DEVICE(pself);
    g_return_val_if_fail (self != NULL, FALSE);
    g_return_val_if_fail (device_name != NULL, FALSE);
    
    /* First thing first. Do we have a directory? */
    if (!check_is_dir(device_name, TRUE)) {
        return FALSE;
    }

    /* Now, figure out if we are using old or new mode.
     * If there is a subdirectory (or link to one) named 'data', we
     * use that instead. */
    subdir = g_strconcat(device_name, "/data/", NULL);
    if (check_is_dir(subdir, FALSE)) {
        amfree(device_name);
        device_name = subdir;
    }

    /* Next open the directory itself. */
    self->dir_handle = opendir(device_name);
    if (self->dir_handle == NULL) {
        fprintf(stderr, "Couldn't open directory %s for reading: %s\n",
                device_name, strerror(errno));
        amfree(device_name);
        return FALSE;
    }

    self->dir_name = device_name;

    if (!open_lock(self, -1, FALSE))
        return FALSE;

    /* Check size of existing files. */
    update_volume_size(self);
    
    /* Not an error if this fails. Note that we ignore the class hierarchy.
     */
    vfs_device_seek_file(pself, 0);

    if (device_parent_class->open_device) {
        return (device_parent_class->open_device)(pself, device_name);
    } else {
        return TRUE;
    }
}

/* A SearchDirectoryFunctor */
static gboolean delete_vfs_files_functor(const char * filename,
                                         gpointer user_data) {
    VfsDevice * self;
    char * path_name;

    self = VFS_DEVICE(user_data);
    g_return_val_if_fail(self != NULL, FALSE);

    /* Skip the volume lock. */
    if (strcmp(filename, VOLUME_LOCKFILE_NAME) == 0)
        return TRUE;

    path_name = vstralloc(self->dir_name, "/", filename, NULL);
    if (unlink(path_name) != 0) {
        fprintf(stderr, "Error unlinking %s: %s\n", path_name,
                strerror(errno));
    }
    amfree(path_name);
    return TRUE;
}

/* delete_vfs_files deletes all VfsDevice files in the directory except the
   volume lockfile. */
static gboolean delete_vfs_files(VfsDevice * self) {
    g_assert(self != NULL);
    g_assert(self->dir_handle != NULL);

    /* This function assumes that the volume is locked! */
    search_directory(self->dir_handle, VFS_DEVICE_FILE_REGEX,
                     delete_vfs_files_functor, self);
    return TRUE;
}

/* This is a functor suitable for search_directory. It simply prints a
   warning. It also dodges the volume lockfile. */
static gboolean check_dir_empty_functor(const char * filename,
                                        gpointer user_data) {
    VfsDevice * self;
    char * path_name;

    self = VFS_DEVICE(user_data);
    g_return_val_if_fail(self != NULL, FALSE);

    if (strcmp(filename, VOLUME_LOCKFILE_NAME) == 0)
        return TRUE;

    path_name = vstralloc(self->dir_name, "/", filename, NULL);

    fprintf(stderr, "Found spurious storage file %s\n", path_name);

    amfree(path_name);
    return TRUE;
}

/* clear_and_label will erase the contents of the directory, and write
 * this label in its place. This is not really tricky, but we have to
 * be careful with locks. */
static gboolean clear_and_prepare_label(VfsDevice * self, char * label) {
    FdDevice * fd_self = FD_DEVICE(self);

    release_file(self);

    /* Delete any extant data, except our volume lock. */
    if (!delete_vfs_files(self)) {
        return FALSE;
    }

    /* Print warnings about any remaining files. */
    search_directory(self->dir_handle, VFS_DEVICE_FILE_REGEX,
                     check_dir_empty_functor, self);

    self->file_name = g_strdup_printf("%s/00000.%s", self->dir_name, label);

    fd_self->fd = robust_open(self->file_name, O_CREAT | O_EXCL | O_WRONLY,
                              VFS_DEVICE_CREAT_MODE);
    if (fd_self->fd < 0) {
        fprintf(stderr, "Can't open file %s: %s\n", self->file_name,
                strerror(errno));
        return FALSE;
    }
    return TRUE;
}

static gboolean vfs_device_read_label(Device * self) {
    vfs_device_seek_file(self, 0);

    if (device_parent_class->read_label) {
        return (device_parent_class->read_label)(self);
    } else {
        return FALSE;
    }
}

static gboolean vfs_device_write_block(Device * pself, guint size,
                                       gpointer data, gboolean last_block) {
    VfsDevice * self = VFS_DEVICE(pself);
    g_return_val_if_fail(self != NULL, FALSE);

    if (self->volume_limit > 0 &&
        self->volume_bytes + size > self->volume_limit) {
        /* Simulate EOF. */
        pself->is_eof = TRUE;
        return FALSE;
    }

    if (device_parent_class->write_block) {
        gboolean result;
        result = device_parent_class->write_block(pself, size, data,
                                                  last_block);
        if (result) {
            self->volume_bytes += size;
        }

        return result;
    } else {
        /* We depend on FD device. */
        g_assert_not_reached();
        return FALSE;
    }
}

static gboolean	vfs_device_start(Device * pself,
                                 DeviceAccessMode mode, char * label,
                                 char * timestamp) {
    gboolean rval;
    VfsDevice * self;
    self = VFS_DEVICE(pself);
    g_return_val_if_fail(self != NULL, FALSE);
    g_return_val_if_fail(device_parent_class->start != NULL, FALSE);
    
    if (mode == ACCESS_WRITE) {
        promote_volume_lock(self);
        if (!clear_and_prepare_label(self, label)) {
            demote_volume_lock(self);
            return FALSE;
        }
    }

    /* This will write the label. */
    rval = device_parent_class->start(pself, mode, label, timestamp);

    if (mode == ACCESS_WRITE) {
        demote_volume_lock(self);
    }

    release_file(self);
 
    return rval;
}

typedef struct {
    VfsDevice * self;
    int rval;
} glfn_data;

/* A SearchDirectoryFunctor. */
static gboolean get_last_file_number_functor(const char * filename,
                                             gpointer datap) {
    guint64 file;
    glfn_data * data = (glfn_data*)datap;
    g_return_val_if_fail(IS_VFS_DEVICE(data->self), FALSE);
    file = g_ascii_strtoull(filename, NULL, 10); /* Guaranteed to work. */
    if (file > G_MAXINT) {
        fprintf(stderr, "Super-large device file %s found, ignoring.\n",
               filename);
        return TRUE;
    }
    /* This condition is needlessly complex due to sign issues. */
    if (data->rval < 0 || ((guint)data->rval) < file) {
        data->rval = file;
    }
    return TRUE;
}

static gint get_last_file_number(VfsDevice * self) {
    glfn_data data;
    int count;
    data.self = self;
    data.rval = -1;
    
    count = search_directory(self->dir_handle, "^[0-9]+\\.",
                             get_last_file_number_functor, &data);

    if (count <= 0) {
        /* Somebody deleted something important while we weren't looking. */
        fprintf(stderr, "Error identifying VFS device contents!\n");
        return -1;
    } else {
        g_assert(data.rval >= 0);
    }
    
    return data.rval;
}

/* Finds the file number, acquires a lock, and returns the new file name. */
static
char * make_new_file_name(VfsDevice * self, const dumpfile_t * ji) {
    char * rval;
    char *base, *sanitary_base;
    int fileno;

    for (;;) {
        fileno = 1 + get_last_file_number(self);
        if (fileno <= 0)
            return NULL;
    
        if (open_lock(self, fileno, TRUE)) {
            break;
        } else {
            continue;
        }
    }

    base = g_strdup_printf("%05d.%s.%s.%d", fileno, ji->name, ji->disk,
                           ji->dumplevel);
    sanitary_base = sanitise_filename(base);
    amfree(base);
    rval = g_strdup_printf("%s/%s", self->dir_name, sanitary_base);
    amfree(sanitary_base);
    return rval;
}

static gboolean 
vfs_device_start_file (Device * pself, const dumpfile_t * ji) {
    VfsDevice * self;
    FdDevice * fd_self;

    self = VFS_DEVICE(pself);
    fd_self = (FdDevice*)self;
    g_return_val_if_fail (self != NULL, FALSE);
    g_return_val_if_fail (ji != NULL, FALSE);

    if (self->volume_limit > 0 &&
        self->volume_bytes + DISK_BLOCK_BYTES > self->volume_limit) {
        /* No more room. */
        return FALSE;
    }

    /* The basic idea here is thus:
       1) Try to get a lock on the next filenumber.
       2) If that fails, update our idea of "next filenumber" and try again.
       3) Then open the file itself.
       4) Chain up. */

    self->file_name = make_new_file_name(self, ji);
    if (self->file_name == NULL)
        return FALSE;

    fd_self->fd = robust_open(self->file_name, O_CREAT | O_EXCL | O_RDWR,
                              VFS_DEVICE_CREAT_MODE);
    if (fd_self->fd < 0) {
        fprintf(stderr, "Can't create file %s: %s\n", self->file_name,
                strerror(errno));
        release_file(self);
        return FALSE;
    }

    /* That's all folks, pass it on down.  */
    if (device_parent_class->start_file &&
        device_parent_class->start_file(pself, ji)) {
        self->volume_bytes += DISK_BLOCK_BYTES;
        return TRUE;
    }

    /* Something broke. */
    release_file(self);
    return FALSE;
}

static gboolean 
vfs_device_finish_file (Device * pself) {
    VfsDevice * self;
    self = VFS_DEVICE(pself);
    g_return_val_if_fail(self != NULL, FALSE);

    release_file(self);
    
    if (device_parent_class->finish_file) {
        return device_parent_class->finish_file(pself);
    } else {
        return TRUE;
    }
    g_assert_not_reached();
}

/* This function is used for two purposes, rather than one. In
 * addition to its documented behavior, we also use it to open the
 * volume label for reading at startup. In that second case, we avoid
 * FdDevice-related side effects. */
static dumpfile_t * 
vfs_device_seek_file (Device * pself, guint file) {
    VfsDevice * self;
    FdDevice * fd_self;

    self = VFS_DEVICE(pself);
    g_return_val_if_fail (self != NULL, NULL);
    fd_self = (FdDevice*) self;

    pself->in_file = FALSE;
    
    release_file(self);

    if (!open_lock(self, file, FALSE)) {
        return NULL;
    }

    self->file_name = file_number_to_file_name(self, file);
    if (self->file_name == NULL) {
        return NULL;
    }

    fd_self->fd = robust_open(self->file_name, O_RDONLY, 0);
    if (fd_self->fd <= 0) {
        fprintf(stderr, "Couldn't open file %s: %s\n", self->file_name,
                strerror(errno));
        amfree(self->file_name);
        return NULL;
    }
    fcntl(fd_self->fd, F_SETFD, TRUE); /* Close on EXEC; Ignore result. */

    if (file > 0) {
        /* Chain up */
        if (device_parent_class->seek_file) {
            return device_parent_class->seek_file(pself, file);
        }
    }
    
    return NULL;
}

static gboolean 
vfs_device_seek_block (Device * pself, guint64 block) {
    VfsDevice * self;
    FdDevice * fd_self;
    off_t result;

    self = VFS_DEVICE(pself);
    fd_self = (FdDevice*)(self);
    g_return_val_if_fail (self != NULL, FALSE);
    g_return_val_if_fail (fd_self->fd >= 0, FALSE);
    g_assert(sizeof(off_t) >= sizeof(guint64));

    /* Pretty simple. We figure out the blocksize and use that. */
    result = lseek(fd_self->fd, (block + 1) * self->block_size, SEEK_SET);
    return (result != (off_t)(-1));
}

static gboolean
vfs_device_property_get (Device * pself, DevicePropertyId ID, GValue * val) {
    VfsDevice * self;
    self = VFS_DEVICE(pself);
    g_return_val_if_fail(self != NULL, FALSE);
    if (ID == PROPERTY_BLOCK_SIZE) {
        g_value_unset_init(val, G_TYPE_INT);
        g_value_set_int(val, self->block_size);
        return TRUE;
    } else if (ID == PROPERTY_MAX_VOLUME_USAGE) {
        g_value_unset_init(val, G_TYPE_UINT64);
        g_value_set_uint64(val, self->volume_limit);
        return TRUE;
    } else {
        if (device_parent_class->property_get) {
            return device_parent_class->property_get(pself, ID, val);
        } else {
            return FALSE;
        }
    }
    g_assert_not_reached();
}

static gboolean 
vfs_device_property_set (Device * pself, DevicePropertyId ID, GValue * val) {
    VfsDevice * self;
    self = VFS_DEVICE(pself);
    g_return_val_if_fail(self != NULL, FALSE);
    if (ID == PROPERTY_BLOCK_SIZE) {
        int block_size = g_value_get_int(val);
        g_return_val_if_fail(block_size > 0, FALSE);
        self->block_size = block_size;
        return TRUE;
    } else if (ID == PROPERTY_MAX_VOLUME_USAGE) {
        self->volume_limit = g_value_get_uint64(val);
        return TRUE;
    } else {
        if (device_parent_class->property_get) {
            return device_parent_class->property_get(pself, ID, val);
        } else {
            return FALSE;
        }
    }
    g_assert_not_reached();
}

static gboolean try_unlink(const char * file) {
    if (unlink(file) < 0) {
        fprintf(stderr, "Can't unlink file %s: %s\n", file, strerror(errno));
        return FALSE;
    } else {
        return TRUE;
    }
}

static gboolean 
vfs_device_recycle_file (Device * pself, guint filenum) {
    VfsDevice * self;

    self = VFS_DEVICE(pself);
    g_return_val_if_fail(self != NULL, FALSE);
    g_return_val_if_fail(!(pself->in_file), FALSE);

    /* Game Plan:
     * 1) Get a write lock on the file in question.
     * 2) Unlink the file in question.
     * 3) Unlink the lock.
     * 4) Release the lock.
     * FIXME: Is it OK to unlink the lockfile?
     */

    self->file_name = file_number_to_file_name(self, filenum);

    if (self->file_name == NULL)
        return FALSE;

    if (!open_lock(self, filenum, TRUE))
        return FALSE;

    if (!try_unlink(self->file_name) ||
        !try_unlink(self->file_lock_name)) {
        release_file(self);
        return FALSE;
    }

    release_file(self);
    return TRUE;
}

static void vfs_device_label_size_range(FdDevice * self G_GNUC_UNUSED,
                                        guint*min, guint*max) {
    if (min != NULL) {
        *min = DISK_BLOCK_BYTES;
    }
    if (max != NULL) {
        *max = DISK_BLOCK_BYTES;
    }
}
